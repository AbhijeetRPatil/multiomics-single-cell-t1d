---
title: "Seurat and Doublet Finder"
---


### STEP 1: INSTALL  and LOAD NECESSARY TOOLS ### 

# install devtools
```{r}
install.packages("devtools")
```

# install hdf5r
```{r}
devtools::install_github("hhoeflin/hdf5r")
```

# load hdf5r
```{r}
library(hdf5r)
```

# install Seurat
```{r}
install.packages('Seurat')
```

# load dplyr
```{r}
library(dplyr)
```

# load Seurat
```{r}
library(Seurat)
```

# check versions of things you loaded
```{r}
sessionInfo()
```


### STEP 2: LOAD DATA ###

## load the data set
```{r}
Human.data <- Read10X(data.dir = "filtered_feature_bc_matrix")
```

# Initialize the Seurat object with the raw (non-normalized data).  Keep all
# genes expressed in >= 3 cells (~0.01% of the data). Keep all cells with at
# least 200 detected genes (1/10 the sample with the lowest gene number)
```{r}
All_Islet <- CreateSeuratObject(counts = Human.data, min.cells = 3, min.features = 200, 
    project = "All_Islet")
```


```{r}
All_Islet_Check <- CreateSeuratObject(counts = Human.data, 
    project = "All_Islet")
```


# get details on All_Iselt
```{r}
All_Islet
```


### STEP 3: QC and selecting cells for further analysis ####
#While the CreateSeuratObject imposes a basic minimum gene-cutoff, you may want to filter out cells at this stage based on technical or biological parameters. Seurat allows you to easily explore QC metrics and filter cells based on any user-defined criteria. In the example below, we visualize gene and molecule counts, plot their relationship, and exclude cells with a clear outlier number of genes detected as potential multiplets. Of course this is not a guaranteed method to exclude cell doublets, but we include this as an example of filtering user-defined outlier cells. We also filter cells based on the percentage of mitochondrial genes present.

# The number of genes and UMIs (nGene and nUMI) are automatically calculated
# for every object by Seurat.  For non-UMI data, nUMI represents the sum of
# the non-normalized values within a cell We calculate the percentage of
# mitochondrial genes here and store it in percent.mito using AddMetaData.
# We use object@raw.data since this represents non-transformed and
# non-log-normalized counts The % of UMI mapping to MT-genes is a common
# scRNA-seq QC metric.

# grab mitochondrial reads
```{r}
# The [[ operator can add columns to object metadata. This is a great place to stash QC stats
All_Islet[["percent.mt"]] <- PercentageFeatureSet(All_Islet, pattern = "^MT-")
```

# AddMetaData adds columns to object@meta.data, and is a great place to
# stash QC stats
```{r}
# Visualize QC metrics as a violin plot
pdf('nGene_nUMI_percentMito.pdf') 
VlnPlot(All_Islet, features = c("nFeature_RNA", "nCount_RNA", "percent.mt"), ncol = 3, pt.size = 0.001)
dev.off()
```


#plot nGene alone
```{r}
# Visualize QC metrics as a violin plot
pdf('nGene.pdf') 
VlnPlot(All_Islet, features = c("nFeature_RNA"), pt.size = 0.001)
dev.off()
```

#plot nCount_RNA alone
```{r}
# Visualize QC metrics as a violin plot
pdf('nCount_RNA.pdf') 
VlnPlot(All_Islet, features = c("nCount_RNA"), pt.size = 0.001)
dev.off()
```

#plot percent.mt alone
```{r}
# Visualize QC metrics as a violin plot
pdf('percent.mt.pdf') 
VlnPlot(All_Islet, features = c("percent.mt"), pt.size = 0.001)
dev.off()
```


# QC plots together
```{r}
# FeatureScatter is typically used to visualize feature-feature relationships, but can be used
# for anything calculated by the object, i.e. columns in object metadata, PC scores etc.
pdf('nUMIvsnGene_nUMIvspercentMito.pdf') 
plot1 <- FeatureScatter(All_Islet, feature1 = "nCount_RNA", feature2 = "percent.mt")
plot2 <- FeatureScatter(All_Islet, feature1 = "nCount_RNA", feature2 = "nFeature_RNA")
CombinePlots(plots = list(plot1, plot2))
dev.off()
```

# QC plots separate
```{r}
# FeatureScatter is typically used to visualize feature-feature relationships, but can be used
# for anything calculated by the object, i.e. columns in object metadata, PC scores etc.
pdf('nUMIvspercentMito.pdf') 
FeatureScatter(All_Islet, feature1 = "nCount_RNA", feature2 = "percent.mt")
dev.off()
```

# QC plots separate
```{r}
# FeatureScatter is typically used to visualize feature-feature relationships, but can be used
# for anything calculated by the object, i.e. columns in object metadata, PC scores etc.
pdf('nUMIvsnGene.pdf') 
FeatureScatter(All_Islet, feature1 = "nCount_RNA", feature2 = "nFeature_RNA")
dev.off()
```

# filter/subset data
```{r}
All_Islet_Filtered1 <- subset(All_Islet, subset = nFeature_RNA > 200 & nFeature_RNA < 8750 & percent.mt < 25 & nCount_RNA < 125000)
```

```{r}
All_Islet_Filtered1
```

### STEP 4: Normalizing Data ###


```{r}
All_Islet_Filtered1_Normalized <- NormalizeData(All_Islet_Filtered1, normalization.method = "LogNormalize", scale.factor = 10000)
```

### STEP 5: DETECTION OF VARIABLE GENES ###

## Seurat calculates highly variable genes and focuses on these for downstream analysis. FindVariableGenes calculates the average expression and dispersion for each gene, places these genes into bins, and then calculates a z-score for dispersion within each bin. This helps control for the relationship between variability and average expression. This function is unchanged from (Macosko et al.), but new methods for variable gene expression identification are coming soon. We suggest that users set these parameters to mark visual outliers on the dispersion plot, but the exact parameter settings may vary based on the data type, heterogeneity in the sample, and normalization strategy. The parameters here identify ~2,000 variable genes, and represent typical parameter settings for UMI data that is normalized to a total of 1e4 molecules.


```{r}
All_Islet_Filtered1_Normalized_VariableGenes <- FindVariableFeatures(All_Islet_Filtered1_Normalized, selection.method = "vst", nfeatures = 2000)
```

```{r}
# Identify the 10 most highly variable genes
top2000<- head(VariableFeatures(All_Islet_Filtered1_Normalized_VariableGenes), 2000)
top2000
# plot variable features with and without labels
pdf('VariableGenes.pdf') 
plot1 <- VariableFeaturePlot(All_Islet_Filtered1_Normalized_VariableGenes)
#plot2 <- LabelPoints(plot = plot1, points = top10)
CombinePlots(plots = list(plot1, plot2))
dev.off()
```


```{r}
top25<- head(VariableFeatures(All_Islet_Filtered1_Normalized_VariableGenes), 25)
top25
```

```{r}
pdf('VariableGenes_2.pdf') 
plot1 <- VariableFeaturePlot(All_Islet_Filtered1_Normalized_VariableGenes)
plot2 <- LabelPoints(plot = plot1, points = top25, repel = TRUE)
plot2
dev.off()
```



### STEP 6: Scaling the data and removing unwanted sources of variation ###

```{r}
all.genes <- rownames(All_Islet_Filtered1_Normalized_VariableGenes)
All_Islet_Filtered1_Normalized_VariableGenes_Scaled <- ScaleData(All_Islet_Filtered1_Normalized_VariableGenes, features = all.genes)
```

### STEP 7: Perform linear dimensional reduction ###

## Next we perform PCA on the scaled data. By default, the genes in object@var.genes are used as input, but can be defined using pc.genes. We have typically found that running dimensionality reduction on highly variable genes can improve performance. However, with UMI data - particularly after regressing out technical variables, we often see that PCA returns similar (albeit slower) results when run on much larger subsets of genes, including the whole transcriptome. ## Next we perform PCA on the scaled data. By default, only the previously determined variable features are used as input, but can be defined using features argument if you wish to choose a different subset.

```{r}
All_Islet_Filtered1_Normalized_VariableGenes_Scaled_PCA <- RunPCA(All_Islet_Filtered1_Normalized_VariableGenes_Scaled, features = VariableFeatures(object = All_Islet_Filtered1_Normalized_VariableGenes_Scaled))
```


```{r}
# Examine and visualize PCA results a few different ways
print(All_Islet_Filtered1_Normalized_VariableGenes_Scaled_PCA[["pca"]], dims = 1:5, nfeatures = 5)
```



```{r}
pdf('VizDimLoadings_PCA.pdf') 
VizDimLoadings(All_Islet_Filtered1_Normalized_VariableGenes_Scaled_PCA, dims = 1:2, reduction = "pca")
dev.off()
```

```{r}
pdf('DimPlot_PCA.pdf') 
DimPlot(All_Islet_Filtered1_Normalized_VariableGenes_Scaled_PCA, reduction = "pca")
dev.off()
```


```{r}
pdf('DimHeatmap_PCA_1.pdf') 
DimHeatmap(All_Islet_Filtered1_Normalized_VariableGenes_Scaled_PCA, dims = 1, cells = 500, balanced = TRUE)
dev.off()
```

```{r}
pdf('DimHeatmap_PCA_1to9.pdf') 
DimHeatmap(All_Islet_Filtered1_Normalized_VariableGenes_Scaled_PCA, dims = 1:9, cells = 500, balanced = TRUE)
dev.off()
```

```{r}
pdf('DimHeatmap_PCA_10to18.pdf') 
DimHeatmap(All_Islet_Filtered1_Normalized_VariableGenes_Scaled_PCA, dims = 10:18, cells = 500, balanced = TRUE)
dev.off()
```

```{r}
pdf('DimHeatmap_PCA_19to27.pdf') 
DimHeatmap(All_Islet_Filtered1_Normalized_VariableGenes_Scaled_PCA, dims = 19:27, cells = 500, balanced = TRUE)
dev.off()
```



### STEP 8: Determine the ‘dimensionality’ of the dataset ###

# To overcome the extensive technical noise in any single feature for scRNA-seq data, Seurat clusters cells based on their PCA scores, with each PC essentially representing a ‘metafeature’ that combines information across a correlated feature set. The top principal components therefore represent a robust compression of the dataset. However, how many componenets should we choose to include? 10? 20? 100?

# In Macosko et al, we implemented a resampling test inspired by the JackStraw procedure. We randomly permute a subset of the data (1% by default) and rerun PCA, constructing a ‘null distribution’ of feature scores, and repeat this procedure. We identify ‘significant’ PCs as those who have a strong enrichment of low p-value features.


```{r}
# NOTE: This process can take a long time for big datasets, comment out for expediency. More
# approximate techniques such as those implemented in ElbowPlot() can be used to reduce
# computation time
All_Islet_Filtered1_Normalized_VariableGenes_Scaled_PCA_Jack <- JackStraw(All_Islet_Filtered1_Normalized_VariableGenes_Scaled_PCA, num.replicate = 100)
All_Islet_Filtered1_Normalized_VariableGenes_Scaled_PCA_Jack <- ScoreJackStraw(All_Islet_Filtered1_Normalized_VariableGenes_Scaled_PCA_Jack, dims = 1:20)
```


```{r}
pdf('Jackstraw_3.pdf') 
JackStrawPlot(All_Islet_Filtered1_Normalized_VariableGenes_Scaled_PCA_Jack, dims = 1:20)
dev.off()
```


```{r}
pdf('ElbowPlot.pdf') 
ElbowPlot(All_Islet_Filtered1_Normalized_VariableGenes_Scaled_PCA_Jack)
dev.off()
```


#Identifying the true dimensionality of a dataset – can be challenging/uncertain for the user. We therefore suggest these three approaches to consider. The first is more supervised, exploring PCs to determine relevant sources of heterogeneity, and could be used in conjunction with GSEA for example. The second implements a statistical test based on a random null model, but is time-consuming for large datasets, and may not return a clear PC cutoff. The third is a heuristic that is commonly used, and can be calculated instantly. In this example, all three approaches yielded similar results, but we might have been justified in choosing anything between PC 7-12 as a cutoff.

#We chose 10 here, but encourage users to consider the following:

#Dendritic cell and NK aficionados may recognize that genes strongly associated with PCs 12 and 13 define rare immune subsets (i.e. MZB1 is a marker for plasmacytoid DCs). However, these groups are so rare, they are difficult to distinguish from background noise for a dataset of this size without prior knowledge.
#We encourage users to repeat downstream analyses with a different number of PCs (10, 15, or even 50!). As you will observe, the results often do not differ dramatically.
#We advise users to err on the higher side when choosing this parameter. For example, performing downstream analyses with only 5 PCs does signifcanltly and adversely affect results.


### STEP 9: Cluster the cells ###

#Seurat v3 applies a graph-based clustering approach, building upon initial strategies in (Macosko et al). Importantly, the distance metric which drives the clustering analysis (based on previously identified PCs) remains the same. However, our approach to partioning the cellular distance matrix into clusters has dramatically improved. Our approach was heavily inspired by recent manuscripts which applied graph-based clustering approaches to scRNA-seq data [SNN-Cliq, Xu and Su, Bioinformatics, 2015] and CyTOF data [PhenoGraph, Levine et al., Cell, 2015]. Briefly, these methods embed cells in a graph structure - for example a K-nearest neighbor (KNN) graph, with edges drawn between cells with similar feature expression patterns, and then attempt to partition this graph into highly interconnected ‘quasi-cliques’ or ‘communities’.

#As in PhenoGraph, we first construct a KNN graph based on the euclidean distance in PCA space, and refine the edge weights between any two cells based on the shared overlap in their local neighborhoods (Jaccard similarity). This step is performed using the FindNeighbors function, and takes as input the previously defined dimensionality of the dataset (first 10 PCs).

#To cluster the cells, we next apply modularity optimization techniques such as the Louvain algorithm (default) or SLM [SLM, Blondel et al., Journal of Statistical Mechanics], to iteratively group cells together, with the goal of optimizing the standard modularity function. The FindClusters function implements this procedure, and contains a resolution parameter that sets the ‘granularity’ of the downstream clustering, with increased values leading to a greater number of clusters. We find that setting this parameter between 0.4-1.2 typically returns good results for single-cell datasets of around 3K cells. Optimal resolution often increases for larger datasets. The clusters can be found using the Idents function.


```{r}
All_Islet_Filtered1_Normalized_VariableGenes_Scaled_PCA_Jack_Cluster <- FindNeighbors(All_Islet_Filtered1_Normalized_VariableGenes_Scaled_PCA_Jack, dims = 1:17)
All_Islet_Filtered1_Normalized_VariableGenes_Scaled_PCA_Jack_Cluster <- FindClusters(All_Islet_Filtered1_Normalized_VariableGenes_Scaled_PCA_Jack_Cluster, resolution = 1.2)
```

```{r}
# Look at cluster IDs of the first 5 cells
head(Idents(All_Islet_Filtered1_Normalized_VariableGenes_Scaled_PCA_Jack_Cluster), 5)
```

### STEP 10: UMAP ###


# Seurat offers several non-linear dimensional reduction techniques, such as tSNE and UMAP, to visualize and explore these datasets. The goal of these algorithms is to learn the underlying manifold of the data in order to place similar cells together in low-dimensional space. Cells within the graph-based clusters determined above should co-localize on these dimension reduction plots. As input to the UMAP and tSNE, we suggest using the same PCs as input to the clustering analysis.

# install UMAP
```{r}
library(reticulate)
use_condaenv(condaenv="Renv", conda="/mnt/data0/apps/anaconda/Anaconda2-5.2/bin/conda")
library(Seurat)
```



```{r}
reticulate::py_install(packages = 'umap-learn')
```



```{r}
All_Islet_Filtered1_Normalized_VariableGenes_Scaled_PCA_Jack_Cluster_UMAP <- RunUMAP(All_Islet_Filtered1_Normalized_VariableGenes_Scaled_PCA_Jack_Cluster, dims = 1:17)

```

```{r}
pdf('UMAP_17PC_1.2gran_5.22.20.pdf') 
DimPlot(All_Islet_Filtered1_Normalized_VariableGenes_Scaled_PCA_Jack_Cluster_UMAP, reduction = "umap", label = TRUE)
dev.off()
```

```{r}
saveRDS(All_Islet_Filtered1_Normalized_VariableGenes_Scaled_PCA_Jack_Cluster_UMAP, file = "All_Islet_Filtered1_Normalized_VariableGenes_Scaled_PCA_Jack_Cluster_UMAP.rds")
```


### STEP 11: Finding differentially expressed features (cluster biomarkers) ###

#Seurat can help you find markers that define clusters via differential expression. By default, it identifes positive and negative markers of a single cluster (specified in ident.1), compared to all other cells. FindAllMarkers automates this process for all clusters, but you can also test groups of clusters vs. each other, or against all cells.

#The min.pct argument requires a feature to be detected at a minimum percentage in either of the two groups of cells, and the thresh.test argument requires a feature to be differentially expressed (on average) by some amount between the two groups. You can set both of these to 0, but with a dramatic increase in time - since this will test a large number of features that are unlikely to be highly discriminatory. As another option to speed up these computations, max.cells.per.ident can be set. This will downsample each identity class to have no more cells than whatever this is set to. While there is generally going to be a loss in power, the speed increases can be significiant and the most highly differentially expressed features will likely still rise to the top.

```{r}
# find markers for every cluster compared to all remaining cells, report only the positive ones
All_Islet_Filtered1_Normalized_VariableGenes_Scaled_PCA_Jack_Cluster_UMAP.markers <- FindAllMarkers(All_Islet_Filtered1_Normalized_VariableGenes_Scaled_PCA_Jack_Cluster_UMAP, only.pos = TRUE, min.pct = 0.25, logfc.threshold = 0.25)
```


```{r}
All_Islet_Filtered1_Normalized_VariableGenes_Scaled_PCA_Jack_Cluster_UMAP.markers %>% group_by(cluster) %>% top_n(n = 5, wt = avg_logFC)
```


# Seurat has several tests for differential expression which can be set with the test.use parameter (see our DE vignette for details). For example, the ROC test returns the ‘classification power’ for any individual marker (ranging from 0 - random, to 1 - perfect).

```{r}
cluster0.markers <- FindMarkers(All_Islet_Filtered1_Normalized_VariableGenes_Scaled_PCA_Jack_Cluster_UMAP, ident.1 = 0, logfc.threshold = 0.25, test.use = "roc", only.pos = TRUE)
```


# GenesAcrossTrees--immune
# CD3's not found
```{r}
pdf('TcellAcrossUMAP_17PC_1.2gran.pdf')
FeaturePlot(object = All_Islet_Filtered1_Normalized_VariableGenes_Scaled_PCA_Jack_Cluster_UMAP, features= c("PTPRC", "CD4", "CD8A", "CD8B", "TRAC"))
dev.off()
```

# cd19/20 not found, TPSD1 not found, GZMA not found, GZMB low
```{r}
pdf('OtherImmuneAcrossUMAP_17PC_1.2gran.pdf')
FeaturePlot(object = All_Islet_Filtered1_Normalized_VariableGenes_Scaled_PCA_Jack_Cluster_UMAP, features= c("PTPRC", "CD14", "SDS", "TPSAB1", "TPSB2", "SPI1"))
dev.off()
```


# GeneAcrossTrees--other pancreas
```{r}
pdf('OtherPancreasMarkers_17PCs_1.2gran.pdf')
FeaturePlot(object = All_Islet_Filtered1_Normalized_VariableGenes_Scaled_PCA_Jack_Cluster_UMAP, features = c("CPA1", "KRT19", "RGS5", "PDGFRA", "SOX10", "VWF"))
dev.off()
```


# GeneAcrossTrees--Endocrine
```{r}
pdf('EndocrineMarkers_17PC_1.2gran.pdf')
FeaturePlot(object = All_Islet_Filtered1_Normalized_VariableGenes_Scaled_PCA_Jack_Cluster_UMAP, features = c("INS", "IAPP", "SST", "GCG", "PPY", "GHRL"))
dev.off()
```

# GeneAcrossTrees--Endocrine
```{r}
pdf('CD69_14PC_2.0gran.pdf')
FeaturePlot(object = All_Islet_Filtered1_Normalized_VariableGenes_Scaled_PCA_Jack_Cluster_UMAP, features = "CD69")
dev.off()
```

```{r}
library(ggplot2)
```


# Violin Plots
```{r}
pdf('ViolinPlot_EndocrineMarkers_14PC_2.0gran.pdf')
VlnPlot(object = All_Islet_Filtered1_Normalized_VariableGenes_Scaled_PCA_Jack_Cluster_UMAP, features = c("INS", "IAPP", "SST", "GCG", "PPY", "GHRL"))
dev.off()
```


```{r}
pdf('INS_VP_14PC_2.0gran_noPoints.pdf')
VlnPlot(object = All_Islet_Filtered1_Normalized_VariableGenes_Scaled_PCA_Jack_Cluster_UMAP, features = 'INS', pt.size = 0) + theme(legend.position="none")
dev.off()
```



```{r}
pdf('IAPP_VP_14PC_2.0gran_noPoints.pdf')
VlnPlot(object = All_Islet_Filtered1_Normalized_VariableGenes_Scaled_PCA_Jack_Cluster_UMAP, features = 'IAPP', pt.size = 0) + theme(legend.position="none")
dev.off()
```



```{r}
pdf('GCG_VP_14PC_2.0gran_noPoints.pdf')
VlnPlot(object = All_Islet_Filtered1_Normalized_VariableGenes_Scaled_PCA_Jack_Cluster_UMAP, features = 'GCG', pt.size = 0) + theme(legend.position="none")
dev.off()
```


```{r}
pdf('SST_VP_14PC_2.0gran_noPoints.pdf')
VlnPlot(object = All_Islet_Filtered1_Normalized_VariableGenes_Scaled_PCA_Jack_Cluster_UMAP, features = 'SST', pt.size = 0) + theme(legend.position="none")
dev.off()
```




```{r}
pdf('PPY_VP_14PC_2.0gran_noPoints.pdf')
VlnPlot(object = All_Islet_Filtered1_Normalized_VariableGenes_Scaled_PCA_Jack_Cluster_UMAP, features = 'PPY', pt.size = 0) + theme(legend.position="none")
dev.off()
```


```{r}
pdf('GHRL_VP_14PC_2.0gran_noPoints.pdf')
VlnPlot(object = All_Islet_Filtered1_Normalized_VariableGenes_Scaled_PCA_Jack_Cluster_UMAP, features = 'GHRL', pt.size = 0) + theme(legend.position="none")
dev.off()
```


```{r}
pdf('CPA1_VP_14PC_2.0gran_noPoints.pdf')
VlnPlot(object = All_Islet_Filtered1_Normalized_VariableGenes_Scaled_PCA_Jack_Cluster_UMAP, features = 'CPA1', pt.size = 0) + theme(legend.position="none")
dev.off()
```



```{r}
pdf('KRT19_VP_14PC_2.0gran_noPoints.pdf')
VlnPlot(object = All_Islet_Filtered1_Normalized_VariableGenes_Scaled_PCA_Jack_Cluster_UMAP, features = 'KRT19', pt.size = 0) + theme(legend.position="none")
dev.off()
```



```{r}
pdf('RGS5_VP_14PC_2.0gran_noPoints.pdf')
VlnPlot(object = All_Islet_Filtered1_Normalized_VariableGenes_Scaled_PCA_Jack_Cluster_UMAP, features = 'RGS5', pt.size = 0) + theme(legend.position="none")
dev.off()
```

```{r}
pdf('RGS10_VP_14PC_2.0gran_noPoints.pdf')
VlnPlot(object = All_Islet_Filtered1_Normalized_VariableGenes_Scaled_PCA_Jack_Cluster_UMAP, features = 'RGS10', pt.size = 0) + theme(legend.position="none")
dev.off()
```


```{r}
pdf('PDGFRA_VP_14PC_2.0gran_noPoints.pdf')
VlnPlot(object = All_Islet_Filtered1_Normalized_VariableGenes_Scaled_PCA_Jack_Cluster_UMAP, features = 'PDGFRA', pt.size = 0) + theme(legend.position="none")
dev.off()
```



```{r}
pdf('SOX10_VP_14PC_2.0gran_noPoints.pdf')
VlnPlot(object = All_Islet_Filtered1_Normalized_VariableGenes_Scaled_PCA_Jack_Cluster_UMAP, features = 'SOX10', pt.size = 0) + theme(legend.position="none")
dev.off()
```



```{r}
pdf('VWF_VP_14PC_2.0gran_noPoints.pdf')
VlnPlot(object = All_Islet_Filtered1_Normalized_VariableGenes_Scaled_PCA_Jack_Cluster_UMAP, features = 'VWF', pt.size = 0) + theme(legend.position="none")
dev.off()
```


```{r}
pdf('PTPRC_VP_14PC_2.0gran_noPoints.pdf')
VlnPlot(object = All_Islet_Filtered1_Normalized_VariableGenes_Scaled_PCA_Jack_Cluster_UMAP, features = 'PTPRC', pt.size = 0) + theme(legend.position="none")
dev.off()
```


```{r}
pdf('CD4_VP_14PC_2.0gran_noPoints.pdf')
VlnPlot(object = All_Islet_Filtered1_Normalized_VariableGenes_Scaled_PCA_Jack_Cluster_UMAP, features = 'CD4', pt.size = 0) + theme(legend.position="none")
dev.off()
```



```{r}
pdf('CD8A_VP_14PC_2.0gran_noPoints.pdf')
VlnPlot(object = All_Islet_Filtered1_Normalized_VariableGenes_Scaled_PCA_Jack_Cluster_UMAP, features = 'CD8A', pt.size = 0) + theme(legend.position="none")
dev.off()
```


```{r}
pdf('CD8B_VP_14PC_2.0gran_noPoints.pdf')
VlnPlot(object = All_Islet_Filtered1_Normalized_VariableGenes_Scaled_PCA_Jack_Cluster_UMAP, features = 'CD8B', pt.size = 0) + theme(legend.position="none")
dev.off()
```


```{r}
pdf('TRAC_VP_14PC_2.0gran_noPoints.pdf')
VlnPlot(object = All_Islet_Filtered1_Normalized_VariableGenes_Scaled_PCA_Jack_Cluster_UMAP, features = 'TRAC', pt.size = 0) + theme(legend.position="none")
dev.off()
```



```{r}
pdf('CD14_VP_14PC_2.0gran_noPoints.pdf')
VlnPlot(object = All_Islet_Filtered1_Normalized_VariableGenes_Scaled_PCA_Jack_Cluster_UMAP, features = 'CD14', pt.size = 0) + theme(legend.position="none")
dev.off()
```



```{r}
pdf('SDS_VP_14PC_2.0gran_noPoints.pdf')
VlnPlot(object = All_Islet_Filtered1_Normalized_VariableGenes_Scaled_PCA_Jack_Cluster_UMAP, features = 'SDS', pt.size = 0) + theme(legend.position="none")
dev.off()
```



```{r}
pdf('TPSAB1_VP_14PC_2.0gran_noPoints.pdf')
VlnPlot(object = All_Islet_Filtered1_Normalized_VariableGenes_Scaled_PCA_Jack_Cluster_UMAP, features = 'TPSAB1', pt.size = 0) + theme(legend.position="none")
dev.off()
```



```{r}
pdf('TPSB2_VP_14PC_2.0gran_noPoints.pdf')
VlnPlot(object = All_Islet_Filtered1_Normalized_VariableGenes_Scaled_PCA_Jack_Cluster_UMAP, features = 'TPSB2', pt.size = 0) + theme(legend.position="none")
dev.off()
```


```{r}
pdf('SPI1_VP_14PC_2.0gran_noPoints.pdf')
VlnPlot(object = All_Islet_Filtered1_Normalized_VariableGenes_Scaled_PCA_Jack_Cluster_UMAP, features = 'SPI1', pt.size = 0) + theme(legend.position="none")
dev.off()
```


# big heatmap
```{r}
pdf('BigHeatMap.pdf')
top10 <- All_Islet_Filtered1_Normalized_VariableGenes_Scaled_PCA_Jack_Cluster_UMAP.markers %>% group_by(cluster) %>% top_n(n = 10, wt = avg_logFC)
DoHeatmap(All_Islet_Filtered1_Normalized_VariableGenes_Scaled_PCA_Jack_Cluster_UMAP, features = top10$gene) + NoLegend()
dev.off()
```

# big heatmap--top 2
```{r}
pdf('BigHeatMap_top2.pdf')
top2 <- All_Islet_Filtered1_Normalized_VariableGenes_Scaled_PCA_Jack_Cluster_UMAP.markers %>% group_by(cluster) %>% top_n(n = 2, wt = avg_logFC)
DoHeatmap(All_Islet_Filtered1_Normalized_VariableGenes_Scaled_PCA_Jack_Cluster_UMAP, features = top2$gene) + NoLegend()
dev.off()
```

### STEP 12: DoubletFinder ###

# installation 

```{r}
library(Matrix)
```

```{r}
library(fields)
```


```{r}
library(KernSmooth)
```

```{r}
library(modes)
```

```{r}
library(ROCR)
```


```{r}
remotes::install_github('chris-mcginnis-ucsf/DoubletFinder')
```

```{r}
library(DoubletFinder)
```

```{r}
library(parallel)
```

```{r}
detectCores()
```


# firt doublet detection--pK identification--step 1 # this takes a little bit, chill no ground-truth
```{r}
sweep.res.list_AllIslets_9 <- paramSweep_v3(All_Islet_Filtered1_Normalized_VariableGenes_Scaled_PCA_Jack_Cluster_UMAP, PCs = 1:17, sct = FALSE)
```

# first step of doublet detection--pK identification--step 2 # run it again if you get "Warning: closing unused connection" no ground-truth
```{r}
sweep.stats_AllIslets_9 <- summarizeSweep(sweep.res.list_AllIslets_9, GT = FALSE)
```


# first step of doublet detection--pK identification--step 3 no ground-truth
```{r}
pdf('bcmvn.AllIslets_9.pdf')
bcmvn_AllIslets_9 <- find.pK(sweep.stats_AllIslets_9)
dev.off()
```

# first step of doublet detection--pK identification--step 1-4 ##ground-truth
```{r}
## pK Identification (ground-truth)
#sweep.res.list_AllIslets_2 <- paramSweep_v3(All_Islet_Filtered1_Normalized_VariableGenes_Scaled_PCA_Jack_Cluster_UMAP, PCs = 1:14, sct = FALSE)
#gt.calls <- All_Islet_Filtered1_Normalized_VariableGenes_Scaled_PCA_Jack_Cluster_UMAP@meta.data[rownames(sweep.res.list_AllIslets_2[[1]]), "GT"]
#sweep.stats_AllIslet_2 <- summarizeSweep(sweep.res.list_AllIslets_2, GT = TRUE, GT.calls = sweep.res.list_AllIslets_2[[1]])
#pdf('bcmvn.AllIslets_2.pdf')
#bcmvn_kidney <- find.pK(sweep.stats_AllIslet_2)
#dev.off()
```




# second step of doublet detection--Homotypic Doublet Proportion Estimate--step 1
```{r}
homotypic.prop <- modelHomotypic(All_Islet_Filtered1_Normalized_VariableGenes_Scaled_PCA_Jack_Cluster_UMAP@meta.data$ClusteringResults) 
```


# second step of doublet detection--Homotypic Doublet Proportion Estimate--step 2
```{r}
nExp_poi <- round(0.023*length(All_Islet_Filtered1_Normalized_VariableGenes_Scaled_PCA_Jack_Cluster_UMAP@active.ident))
```


# second step of doublet detection--Homotypic Doublet Proportion Estimate--step 3
```{r}
nExp_poi.adj <- round(nExp_poi*(1-homotypic.prop))
```


## third step of DoubletFinder--run doubletfinder with with varying classification stringencies 
# ran with average pK!

```{r}
All_Islet_Filtered1_Normalized_VariableGenes_Scaled_PCA_Jack_Cluster_UMAP.doubletFinder <- doubletFinder_v3(All_Islet_Filtered1_Normalized_VariableGenes_Scaled_PCA_Jack_Cluster_UMAP, PCs = 1:17, pN = 0.25, pK = 0.0725, nExp = nExp_poi, reuse.pANN = FALSE, sct = FALSE)
```


# fourth step of doublet finder: plot results step 1
```{r}
All_Islet_Filtered1_Normalized_VariableGenes_Scaled_PCA_Jack_Cluster_UMAP.doubletFinder@meta.data[,"DF_hi.lo"] <- All_Islet_Filtered1_Normalized_VariableGenes_Scaled_PCA_Jack_Cluster_UMAP.doubletFinder@meta.data$DF.classifications_0.25_0.0725_1690
```


# fourth step of doublet finder: plot results step 2
```{r}
All_Islet_Filtered1_Normalized_VariableGenes_Scaled_PCA_Jack_Cluster_UMAP.doubletFinder@meta.data$DF_hi.lo[which(All_Islet_Filtered1_Normalized_VariableGenes_Scaled_PCA_Jack_Cluster_UMAP.doubletFinder@meta.data$DF_hi.lo == "Doublet" & All_Islet_Filtered1_Normalized_VariableGenes_Scaled_PCA_Jack_Cluster_UMAP.doubletFinder@meta.data$DF.classifications_0.25_0.0725_1690 == "Singlet")] <- "Doublet_lo"
```


# fourth step of doublet finder: plot results step 3
```{r}
All_Islet_Filtered1_Normalized_VariableGenes_Scaled_PCA_Jack_Cluster_UMAP.doubletFinder@meta.data$DF_hi.lo[which(All_Islet_Filtered1_Normalized_VariableGenes_Scaled_PCA_Jack_Cluster_UMAP.doubletFinder@meta.data$DF_hi.lo == "Doublet")] <- "Doublet_hi"
```


# fourth step of doublet finder: plot results step 4
```{r}
pdf('UMAP_doublets_singlets_average_pK.pdf')
UMAPPlot(All_Islet_Filtered1_Normalized_VariableGenes_Scaled_PCA_Jack_Cluster_UMAP.doubletFinder, group.by="DF_hi.lo", order=c("Doublet_hi","Doublet_lo","Singlet"), cols=c("black","gold","red"))
dev.off()
```



```{r}
write.table(as.data.frame(All_Islet_Filtered1_Normalized_VariableGenes_Scaled_PCA_Jack_Cluster_UMAP.doubletFinder@meta.data),
          file="Doublet_Singlets_List_BarcodeNames_average_pK.txt", quote=FALSE, sep = "\t", row.names=TRUE)
```



# running seccond stringency 

## third step of DoubletFinder--fun doubletfinder with with varying classification stringencies 
# 2nd strigency for now

```{r}
All_Islet_Filtered1_Normalized_VariableGenes_Scaled_PCA_Jack_Cluster_UMAP.doubletFinder_2 <- doubletFinder_v3(All_Islet_Filtered1_Normalized_VariableGenes_Scaled_PCA_Jack_Cluster_UMAP, PCs = 1:17, pN = 0.25, pK = 0.0725, nExp = nExp_poi.adj, sct = FALSE)
```

# fourth step of doublet finder: plot results step 1
```{r}
All_Islet_Filtered1_Normalized_VariableGenes_Scaled_PCA_Jack_Cluster_UMAP.doubletFinder_2@meta.data[,"DF_hi.lo"] <- All_Islet_Filtered1_Normalized_VariableGenes_Scaled_PCA_Jack_Cluster_UMAP.doubletFinder_2@meta.data$DF.classifications_0.25_0.0725_1690
```


# fourth step of doublet finder: plot results step 2
```{r}
All_Islet_Filtered1_Normalized_VariableGenes_Scaled_PCA_Jack_Cluster_UMAP.doubletFinder_2@meta.data$DF_hi.lo[which(All_Islet_Filtered1_Normalized_VariableGenes_Scaled_PCA_Jack_Cluster_UMAP.doubletFinder_2@meta.data$DF_hi.lo == "Doublet" & All_Islet_Filtered1_Normalized_VariableGenes_Scaled_PCA_Jack_Cluster_UMAP.doubletFinder_2@meta.data$DF.classifications_0.25_0.0725_169 == "Singlet")] <- "Doublet_lo"
```


# fourth step of doublet finder: plot results step 3
```{r}
All_Islet_Filtered1_Normalized_VariableGenes_Scaled_PCA_Jack_Cluster_UMAP.doubletFinder_2@meta.data$DF_hi.lo[which(All_Islet_Filtered1_Normalized_VariableGenes_Scaled_PCA_Jack_Cluster_UMAP.doubletFinder_2@meta.data$DF_hi.lo == "Doublet")] <- "Doublet_hi"
```


# fourth step of doublet finder: plot results step 4
```{r}
pdf('UMAP_doublets_singlets_2.pdf')
UMAPPlot(All_Islet_Filtered1_Normalized_VariableGenes_Scaled_PCA_Jack_Cluster_UMAP.doubletFinder_2, group.by="DF_hi.lo", order=c("Doublet_hi","Doublet_lo","Singlet"), cols=c("black","gold","red"))
dev.off()
```



```{r}
write.table(as.data.frame(All_Islet_Filtered1_Normalized_VariableGenes_Scaled_PCA_Jack_Cluster_UMAP.doubletFinder_2@meta.data),
          file="Doublet_Singlets_List_BarcodeNames_average_pK_2.txt", quote=FALSE, sep = "\t", row.names=TRUE)
```


# running third stringency 

## third step of DoubletFinder--fun doubletfinder with with varying classification stringencies 
# 3rd stringency--lowest pK


```{r}
All_Islet_Filtered1_Normalized_VariableGenes_Scaled_PCA_Jack_Cluster_UMAP.doubletFinder_3 <- doubletFinder_v3(All_Islet_Filtered1_Normalized_VariableGenes_Scaled_PCA_Jack_Cluster_UMAP, PCs = 1:17, pN = 0.25, pK = 0.055, nExp = nExp_poi.adj, sct = FALSE)
```


# fourth step of doublet finder: plot results step 1
```{r}
All_Islet_Filtered1_Normalized_VariableGenes_Scaled_PCA_Jack_Cluster_UMAP.doubletFinder_3@meta.data[,"DF_hi.lo"] <- All_Islet_Filtered1_Normalized_VariableGenes_Scaled_PCA_Jack_Cluster_UMAP.doubletFinder_3@meta.data$DF.classifications_0.25_0.055_1690
```


# fourth step of doublet finder: plot results step 2
```{r}
All_Islet_Filtered1_Normalized_VariableGenes_Scaled_PCA_Jack_Cluster_UMAP.doubletFinder_3@meta.data$DF_hi.lo[which(All_Islet_Filtered1_Normalized_VariableGenes_Scaled_PCA_Jack_Cluster_UMAP.doubletFinder_3@meta.data$DF_hi.lo == "Doublet" & All_Islet_Filtered1_Normalized_VariableGenes_Scaled_PCA_Jack_Cluster_UMAP.doubletFinder_3@meta.data$DF.classifications_0.25_0.055_1690 == "Singlet")] <- "Doublet_lo"
```


# fourth step of doublet finder: plot results step 3
```{r}
All_Islet_Filtered1_Normalized_VariableGenes_Scaled_PCA_Jack_Cluster_UMAP.doubletFinder_3@meta.data$DF_hi.lo[which(All_Islet_Filtered1_Normalized_VariableGenes_Scaled_PCA_Jack_Cluster_UMAP.doubletFinder_3@meta.data$DF_hi.lo == "Doublet")] <- "Doublet_hi"
```


# fourth step of doublet finder: plot results step 4
```{r}
pdf('UMAP_doublets_singlets_3_min_pk.pdf')
UMAPPlot(All_Islet_Filtered1_Normalized_VariableGenes_Scaled_PCA_Jack_Cluster_UMAP.doubletFinder_3, group.by="DF_hi.lo", order=c("Doublet_hi","Doublet_lo","Singlet"), cols=c("black","gold","red"))
dev.off()
```



```{r}
write.table(as.data.frame(All_Islet_Filtered1_Normalized_VariableGenes_Scaled_PCA_Jack_Cluster_UMAP.doubletFinder_3@meta.data),
          file="Doublet_Singlets_List_BarcodeNames_3_min_pk.txt", quote=FALSE, sep = "\t", row.names=TRUE)
```



# running third stringency 

## third step of DoubletFinder--fun doubletfinder with with varying classification stringencies 
# 4th stringency--highest pK



```{r}
All_Islet_Filtered1_Normalized_VariableGenes_Scaled_PCA_Jack_Cluster_UMAP.doubletFinder_4 <- doubletFinder_v3(All_Islet_Filtered1_Normalized_VariableGenes_Scaled_PCA_Jack_Cluster_UMAP, PCs = 1:17, pN = 0.25, pK = 0.129, nExp = nExp_poi.adj, sct = FALSE)
```



# fourth step of doublet finder: plot results step 1
```{r}
All_Islet_Filtered1_Normalized_VariableGenes_Scaled_PCA_Jack_Cluster_UMAP.doubletFinder_4@meta.data[,"DF_hi.lo"] <- All_Islet_Filtered1_Normalized_VariableGenes_Scaled_PCA_Jack_Cluster_UMAP.doubletFinder_4@meta.data$DF.classifications_0.25_0.129_1690
```


# fourth step of doublet finder: plot results step 2
```{r}
All_Islet_Filtered1_Normalized_VariableGenes_Scaled_PCA_Jack_Cluster_UMAP.doubletFinder_4@meta.data$DF_hi.lo[which(All_Islet_Filtered1_Normalized_VariableGenes_Scaled_PCA_Jack_Cluster_UMAP.doubletFinder_4@meta.data$DF_hi.lo == "Doublet" & All_Islet_Filtered1_Normalized_VariableGenes_Scaled_PCA_Jack_Cluster_UMAP.doubletFinder_4@meta.data$DF.classifications_0.25_0.129_1690 == "Singlet")] <- "Doublet_lo"
```


# fourth step of doublet finder: plot results step 3
```{r}
All_Islet_Filtered1_Normalized_VariableGenes_Scaled_PCA_Jack_Cluster_UMAP.doubletFinder_4@meta.data$DF_hi.lo[which(All_Islet_Filtered1_Normalized_VariableGenes_Scaled_PCA_Jack_Cluster_UMAP.doubletFinder_4@meta.data$DF_hi.lo == "Doublet")] <- "Doublet_hi"
```


# fourth step of doublet finder: plot results step 4
```{r}
pdf('UMAP_doublets_singlets_4_highest_pk.pdf')
UMAPPlot(All_Islet_Filtered1_Normalized_VariableGenes_Scaled_PCA_Jack_Cluster_UMAP.doubletFinder_4, group.by="DF_hi.lo", order=c("Doublet_hi","Doublet_lo","Singlet"), cols=c("black","gold","red"))
dev.off()
```



```{r}
write.table(as.data.frame(All_Islet_Filtered1_Normalized_VariableGenes_Scaled_PCA_Jack_Cluster_UMAP.doubletFinder_4@meta.data),
          file="Doublet_Singlets_List_BarcodeNames_4_highest_pk.txt", quote=FALSE, sep = "\t", row.names=TRUE)
```


```{r}
write.table(as.data.frame(All_Islet$orig.ident),
          file="All_Barcodes.txt", quote=FALSE, sep = "\t", row.names=TRUE)
```




# remove doublets
# attempt using subset 


```{r}
Singlets <- read.delim("Singlets.txt", stringsAsFactors = FALSE, sep = "\t", header = TRUE)
```

```{r}
avector_Singlet_3 <- Singlets[,1]
class(avector_Singlet_3)
```



```{r}
All_Islet_DoubletRemoved <- subset(x = All_Islet, cells = avector_Singlet_3)
```


#### STEPS AFTER DOUBLET REMOVAL #######

### STEP 3: QC and selecting cells for further analysis ####
#While the CreateSeuratObject imposes a basic minimum gene-cutoff, you may want to filter out cells at this stage based on technical or biological parameters. Seurat allows you to easily explore QC metrics and filter cells based on any user-defined criteria. In the example below, we visualize gene and molecule counts, plot their relationship, and exclude cells with a clear outlier number of genes detected as potential multiplets. Of course this is not a guaranteed method to exclude cell doublets, but we include this as an example of filtering user-defined outlier cells. We also filter cells based on the percentage of mitochondrial genes present.

# The number of genes and UMIs (nGene and nUMI) are automatically calculated
# for every object by Seurat.  For non-UMI data, nUMI represents the sum of
# the non-normalized values within a cell We calculate the percentage of
# mitochondrial genes here and store it in percent.mito using AddMetaData.
# We use object@raw.data since this represents non-transformed and
# non-log-normalized counts The % of UMI mapping to MT-genes is a common
# scRNA-seq QC metric.

# grab mitochondrial reads
```{r}
# The [[ operator can add columns to object metadata. This is a great place to stash QC stats
All_Islet_DoubletRemoved[["percent.mt"]] <- PercentageFeatureSet(All_Islet_DoubletRemoved, pattern = "^MT-")
```

# AddMetaData adds columns to object@meta.data, and is a great place to
# stash QC stats
```{r}
# Visualize QC metrics as a violin plot
pdf('nGene_nUMI_percentMito_afterDoubletRemoval.pdf') 
VlnPlot(All_Islet_DoubletRemoved, features = c("nFeature_RNA", "nCount_RNA", "percent.mt"), ncol = 3, pt.size = 0.001)
dev.off()
```

# QC plots together
```{r}
# FeatureScatter is typically used to visualize feature-feature relationships, but can be used
# for anything calculated by the object, i.e. columns in object metadata, PC scores etc.
pdf('nUMIvsnGene_nUMIvspercentMito_afterDoubletRemoved.pdf') 
plot1 <- FeatureScatter(All_Islet_DoubletRemoved, feature1 = "nCount_RNA", feature2 = "percent.mt")
plot2 <- FeatureScatter(All_Islet_DoubletRemoved, feature1 = "nCount_RNA", feature2 = "nFeature_RNA")
CombinePlots(plots = list(plot1, plot2))
dev.off()
```

# QC plots separate
```{r}
# FeatureScatter is typically used to visualize feature-feature relationships, but can be used
# for anything calculated by the object, i.e. columns in object metadata, PC scores etc.
pdf('nUMIvspercentMito_afterDoubletRemoved.pdf') 
FeatureScatter(All_Islet_DoubletRemoved, feature1 = "nCount_RNA", feature2 = "percent.mt")
dev.off()
```

# QC plots separate
```{r}
# FeatureScatter is typically used to visualize feature-feature relationships, but can be used
# for anything calculated by the object, i.e. columns in object metadata, PC scores etc.
pdf('nUMIvsnGene_afterDoubletRemoval.pdf') 
FeatureScatter(All_Islet_DoubletRemoved, feature1 = "nCount_RNA", feature2 = "nFeature_RNA")
dev.off()
```

# filter/subset data## NO FILTERING!

# filter/subset data
```{r}
All_Islet_DoubletRemoved <- subset(All_Islet_DoubletRemoved, subset = nFeature_RNA > 200 & nFeature_RNA < 8750 & percent.mt < 25 & nCount_RNA < 100000)
```

```{r}
All_Islet_DoubletRemoved
```



### STEP 4: Normalizing Data ###


```{r}
All_Islet_DoubletRemoved_Norm <- NormalizeData(All_Islet_DoubletRemoved, normalization.method = "LogNormalize", scale.factor = 10000)
```

### STEP 5: DETECTION OF VARIABLE GENES ###

## Seurat calculates highly variable genes and focuses on these for downstream analysis. FindVariableGenes calculates the average expression and dispersion for each gene, places these genes into bins, and then calculates a z-score for dispersion within each bin. This helps control for the relationship between variability and average expression. This function is unchanged from (Macosko et al.), but new methods for variable gene expression identification are coming soon. We suggest that users set these parameters to mark visual outliers on the dispersion plot, but the exact parameter settings may vary based on the data type, heterogeneity in the sample, and normalization strategy. The parameters here identify ~2,000 variable genes, and represent typical parameter settings for UMI data that is normalized to a total of 1e4 molecules.


```{r}
All_Islet_DoubletRemoved_Norm_VariableGenes <- FindVariableFeatures(All_Islet_DoubletRemoved_Norm, selection.method = "vst", nfeatures = 2000)
```

```{r}
# Identify the 2000 most highly variable genes
top2000<- head(VariableFeatures(All_Islet_DoubletRemoved_Norm_VariableGenes), 2000)
top2000
# plot variable features with and without labels
pdf('VariableGenes_afterDoubletRemoval_plot2.pdf') 
plot1 <- VariableFeaturePlot(All_Islet_DoubletRemoved_Norm_VariableGenes)
#plot2 <- LabelPoints(plot = plot1, points = top2000)
CombinePlots(plots = list(plot1, plot2))
dev.off()
```


```{r}
top25<- head(VariableFeatures(All_Islet_DoubletRemoved_Norm_VariableGenes), 25)
top25
```


```{r}
pdf('VariableGenes_2.pdf') 
plot1 <- VariableFeaturePlot(All_Islet_DoubletRemoved_Norm_VariableGenes)
plot2 <- LabelPoints(plot = plot1, points = top25, repel = TRUE)
plot2
dev.off()
```




### STEP 6: Scaling the data and removing unwanted sources of variation ###

```{r}
all.genes_doubletRemoved <- rownames(All_Islet_DoubletRemoved_Norm_VariableGenes)
All_Islet_DoubletRemoved_Norm_VariableGenes_Scaled <- ScaleData(All_Islet_DoubletRemoved_Norm_VariableGenes, features = all.genes_doubletRemoved)
```

### STEP 7: Perform linear dimensional reduction ###

## Next we perform PCA on the scaled data. By default, the genes in object@var.genes are used as input, but can be defined using pc.genes. We have typically found that running dimensionality reduction on highly variable genes can improve performance. However, with UMI data - particularly after regressing out technical variables, we often see that PCA returns similar (albeit slower) results when run on much larger subsets of genes, including the whole transcriptome. ## Next we perform PCA on the scaled data. By default, only the previously determined variable features are used as input, but can be defined using features argument if you wish to choose a different subset.

```{r}
All_Islet_DoubletRemoved_Norm_VariableGenes_Scaled_PCA <- RunPCA(All_Islet_DoubletRemoved_Norm_VariableGenes_Scaled, features = VariableFeatures(object = All_Islet_DoubletRemoved_Norm_VariableGenes_Scaled))
```


```{r}
# Examine and visualize PCA results a few different ways
print(All_Islet_DoubletRemoved_Norm_VariableGenes_Scaled_PCA[["pca"]], dims = 1:5, nfeatures = 5)
```



```{r}
pdf('VizDimLoadings_PCA_afterDoubletRemoval.pdf') 
VizDimLoadings(All_Islet_DoubletRemoved_Norm_VariableGenes_Scaled_PCA, dims = 1:2, reduction = "pca")
dev.off()
```

```{r}
pdf('DimPlot_PCA_afterDoubletRemoval.pdf') 
DimPlot(All_Islet_DoubletRemoved_Norm_VariableGenes_Scaled_PCA, reduction = "pca")
dev.off()
```


```{r}
pdf('DimHeatmap_PCA_1_afterDoubletRemoval.pdf') 
DimHeatmap(All_Islet_DoubletRemoved_Norm_VariableGenes_Scaled_PCA, dims = 1, cells = 500, balanced = TRUE)
dev.off()
```

```{r}
pdf('DimHeatmap_PCA_1to9_afterDoubletRemoval.pdf') 
DimHeatmap(All_Islet_DoubletRemoved_Norm_VariableGenes_Scaled_PCA, dims = 1:9, cells = 500, balanced = TRUE)
dev.off()
```

```{r}
pdf('DimHeatmap_PCA_10to18_afterdoubletRemoval.pdf') 
DimHeatmap(All_Islet_DoubletRemoved_Norm_VariableGenes_Scaled_PCA, dims = 10:18, cells = 500, balanced = TRUE)
dev.off()
```

```{r}
pdf('DimHeatmap_PCA_19to27_afterDoubletRemoval.pdf') 
DimHeatmap(All_Islet_DoubletRemoved_Norm_VariableGenes_Scaled_PCA, dims = 19:27, cells = 500, balanced = TRUE)
dev.off()
```


```{r}
pdf('DimHeatmap_PCA_28to30_afterDoubletRemoval.pdf') 
DimHeatmap(All_Islet_DoubletRemoved_Norm_VariableGenes_Scaled_PCA, dims = 28:30, cells = 500, balanced = TRUE)
dev.off()
```


### STEP 8: Determine the ‘dimensionality’ of the dataset ###

# To overcome the extensive technical noise in any single feature for scRNA-seq data, Seurat clusters cells based on their PCA scores, with each PC essentially representing a ‘metafeature’ that combines information across a correlated feature set. The top principal components therefore represent a robust compression of the dataset. However, how many componenets should we choose to include? 10? 20? 100?

# In Macosko et al, we implemented a resampling test inspired by the JackStraw procedure. We randomly permute a subset of the data (1% by default) and rerun PCA, constructing a ‘null distribution’ of feature scores, and repeat this procedure. We identify ‘significant’ PCs as those who have a strong enrichment of low p-value features.


```{r}
# NOTE: This process can take a long time for big datasets, comment out for expediency. More
# approximate techniques such as those implemented in ElbowPlot() can be used to reduce
# computation time
All_Islet_DoubletRemoved_Norm_VariableGenes_Scaled_PCA_Jack <- JackStraw(All_Islet_DoubletRemoved_Norm_VariableGenes_Scaled_PCA, num.replicate = 100, dims = 30)
All_Islet_DoubletRemoved_Norm_VariableGenes_Scaled_PCA_Jack <- ScoreJackStraw(All_Islet_DoubletRemoved_Norm_VariableGenes_Scaled_PCA_Jack, dims = 1:30)
```


```{r}
pdf('Jackstraw_afterDoubletRemoval.pdf') 
JackStrawPlot(All_Islet_DoubletRemoved_Norm_VariableGenes_Scaled_PCA_Jack, dims = 1:30)
dev.off()
```


```{r}
pdf('ElbowPlot_afterDoubletRemoval.pdf') 
ElbowPlot(All_Islet_DoubletRemoved_Norm_VariableGenes_Scaled_PCA_Jack, ndims = 30)
dev.off()
```


#Identifying the true dimensionality of a dataset – can be challenging/uncertain for the user. We therefore suggest these three approaches to consider. The first is more supervised, exploring PCs to determine relevant sources of heterogeneity, and could be used in conjunction with GSEA for example. The second implements a statistical test based on a random null model, but is time-consuming for large datasets, and may not return a clear PC cutoff. The third is a heuristic that is commonly used, and can be calculated instantly. In this example, all three approaches yielded similar results, but we might have been justified in choosing anything between PC 7-12 as a cutoff.

#We chose 10 here, but encourage users to consider the following:

#Dendritic cell and NK aficionados may recognize that genes strongly associated with PCs 12 and 13 define rare immune subsets (i.e. MZB1 is a marker for plasmacytoid DCs). However, these groups are so rare, they are difficult to distinguish from background noise for a dataset of this size without prior knowledge.
#We encourage users to repeat downstream analyses with a different number of PCs (10, 15, or even 50!). As you will observe, the results often do not differ dramatically.
#We advise users to err on the higher side when choosing this parameter. For example, performing downstream analyses with only 5 PCs does signifcanltly and adversely affect results.

### STEP 9: Cluster the cells ###

#Seurat v3 applies a graph-based clustering approach, building upon initial strategies in (Macosko et al). Importantly, the distance metric which drives the clustering analysis (based on previously identified PCs) remains the same. However, our approach to partioning the cellular distance matrix into clusters has dramatically improved. Our approach was heavily inspired by recent manuscripts which applied graph-based clustering approaches to scRNA-seq data [SNN-Cliq, Xu and Su, Bioinformatics, 2015] and CyTOF data [PhenoGraph, Levine et al., Cell, 2015]. Briefly, these methods embed cells in a graph structure - for example a K-nearest neighbor (KNN) graph, with edges drawn between cells with similar feature expression patterns, and then attempt to partition this graph into highly interconnected ‘quasi-cliques’ or ‘communities’.

#As in PhenoGraph, we first construct a KNN graph based on the euclidean distance in PCA space, and refine the edge weights between any two cells based on the shared overlap in their local neighborhoods (Jaccard similarity). This step is performed using the FindNeighbors function, and takes as input the previously defined dimensionality of the dataset (first 10 PCs).

#To cluster the cells, we next apply modularity optimization techniques such as the Louvain algorithm (default) or SLM [SLM, Blondel et al., Journal of Statistical Mechanics], to iteratively group cells together, with the goal of optimizing the standard modularity function. The FindClusters function implements this procedure, and contains a resolution parameter that sets the ‘granularity’ of the downstream clustering, with increased values leading to a greater number of clusters. We find that setting this parameter between 0.4-1.2 typically returns good results for single-cell datasets of around 3K cells. Optimal resolution often increases for larger datasets. The clusters can be found using the Idents function.




```{r}
All_Islet_DoubletRemoved_Norm_VariableGenes_Scaled_PCA_Jack_Cluster <- FindNeighbors(All_Islet_DoubletRemoved_Norm_VariableGenes_Scaled_PCA_Jack, dims = 1:26)
All_Islet_DoubletRemoved_Norm_VariableGenes_Scaled_PCA_Jack_Cluster <- FindClusters(All_Islet_DoubletRemoved_Norm_VariableGenes_Scaled_PCA_Jack_Cluster, resolution = 1.2)
```

```{r}
# Look at cluster IDs of the first 5 cells
head(Idents(All_Islet_DoubletRemoved_Norm_VariableGenes_Scaled_PCA_Jack_Cluster ), 5)
```

### STEP 10: UMAP ###


# Seurat offers several non-linear dimensional reduction techniques, such as tSNE and UMAP, to visualize and explore these datasets. The goal of these algorithms is to learn the underlying manifold of the data in order to place similar cells together in low-dimensional space. Cells within the graph-based clusters determined above should co-localize on these dimension reduction plots. As input to the UMAP and tSNE, we suggest using the same PCs as input to the clustering analysis.

# install UMAP
```{r}
library(reticulate)
use_condaenv(condaenv="Renv", conda="/mnt/data0/apps/anaconda/Anaconda2-5.2/bin/conda")
library(Seurat)
```



```{r}
reticulate::py_install(packages = 'umap-learn')
```



```{r}
All_Islet_DoubletRemoved_Norm_VariableGenes_Scaled_PCA_Jack_Cluster_UMAP <- RunUMAP(All_Islet_DoubletRemoved_Norm_VariableGenes_Scaled_PCA_Jack_Cluster, dims = 1:26)

```

```{r}
pdf('UMAP_26PC_1.2gran_afterDoubletRemoval_6.12.20.pdf') 
DimPlot(All_Islet_DoubletRemoved_Norm_VariableGenes_Scaled_PCA_Jack_Cluster_UMAP, reduction = "umap", label = TRUE)
dev.off()
```

```{r}
saveRDS(All_Islet_DoubletRemoved_Norm_VariableGenes_Scaled_PCA_Jack_Cluster_UMAP, file = "All_Islet_DoubletRemoved_Norm_VariableGenes_Scaled_PCA_Jack_Cluster_UMAP.rds")
```


### STEP 11: Finding differentially expressed features (cluster biomarkers) ###

#Seurat can help you find markers that define clusters via differential expression. By default, it identifes positive and negative markers of a single cluster (specified in ident.1), compared to all other cells. FindAllMarkers automates this process for all clusters, but you can also test groups of clusters vs. each other, or against all cells.

#The min.pct argument requires a feature to be detected at a minimum percentage in either of the two groups of cells, and the thresh.test argument requires a feature to be differentially expressed (on average) by some amount between the two groups. You can set both of these to 0, but with a dramatic increase in time - since this will test a large number of features that are unlikely to be highly discriminatory. As another option to speed up these computations, max.cells.per.ident can be set. This will downsample each identity class to have no more cells than whatever this is set to. While there is generally going to be a loss in power, the speed increases can be significiant and the most highly differentially expressed features will likely still rise to the top.

```{r}
# find markers for every cluster compared to all remaining cells, report only the positive ones
All_Islet_DoubletRemoved_Norm_VariableGenes_Scaled_PCA_Jack_Cluster_UMAP.markers <- FindAllMarkers(All_Islet_DoubletRemoved_Norm_VariableGenes_Scaled_PCA_Jack_Cluster_UMAP, only.pos = TRUE, min.pct = 0.25, logfc.threshold = 0.25)
```


```{r}
All_Islet_DoubletRemoved_Norm_VariableGenes_Scaled_PCA_Jack_Cluster_UMAP.markers %>% group_by(cluster) %>% top_n(n = 5, wt = avg_logFC)
```


# Seurat has several tests for differential expression which can be set with the test.use parameter (see our DE vignette for details). For example, the ROC test returns the ‘classification power’ for any individual marker (ranging from 0 - random, to 1 - perfect).

```{r}
cluster0.markers <- FindMarkers(All_Islet_DoubletRemoved_Norm_VariableGenes_Scaled_PCA_Jack_Cluster_UMAP, ident.1 = 0, logfc.threshold = 0.25, test.use = "roc", only.pos = TRUE)
```




# big heatmap
```{r}
pdf('BigHeatMap_afterDoubletRemoval.pdf')
top10 <- All_Islet_DoubletRemoved_Norm_VariableGenes_Scaled_PCA_Jack_Cluster_UMAP.markers %>% group_by(cluster) %>% top_n(n = 10, wt = avg_logFC)
DoHeatmap(All_Islet_DoubletRemoved_Norm_VariableGenes_Scaled_PCA_Jack_Cluster_UMAP, features = top10$gene) + NoLegend()
dev.off()
```

# big heatmap--top 2
```{r}
pdf('BigHeatMap_top2_afterDoubletRemoval.pdf')
top2 <- All_Islet_DoubletRemoved_Norm_VariableGenes_Scaled_PCA_Jack_Cluster_UMAP.markers %>% group_by(cluster) %>% top_n(n = 2, wt = avg_logFC)
DoHeatmap(All_Islet_DoubletRemoved_Norm_VariableGenes_Scaled_PCA_Jack_Cluster_UMAP, features = top2$gene) + NoLegend()
dev.off()
```




# GenesAcrossTrees--immune
# CD3's not found
```{r}
pdf('TcellAcrossTSNE_26PC_1.2gran_afterDoubletRemoval_6.12.20.pdf')
FeaturePlot(object = All_Islet_DoubletRemoved_Norm_VariableGenes_Scaled_PCA_Jack_Cluster_UMAP, features= c("PTPRC", "CD4", "CD8A", "CD8B", "TRAC"))
dev.off()
```

# cd19/20 not found, TPSD1 not found, GZMA not found, GZMB low
```{r}
pdf('OtherImmuneAcrossTSNE_26PC_1.2gran_afterDoubletRemoval_6.12.20.pdf')
FeaturePlot(object = All_Islet_DoubletRemoved_Norm_VariableGenes_Scaled_PCA_Jack_Cluster_UMAP, features= c("PTPRC", "CD14", "SDS", "TPSAB1", "TPSB2", "SPI1"))
dev.off()
```


# GeneAcrossTrees--other pancreas
```{r}
pdf('OtherPancreasMarkers_26PCs_1.2gran_afterDoubletRemoval_6.12.20.pdf')
FeaturePlot(object = All_Islet_DoubletRemoved_Norm_VariableGenes_Scaled_PCA_Jack_Cluster_UMAP, features = c("CPA1", "KRT19", "RGS10", "PDGFRA", "SOX10", "VWF"))
dev.off()
```


# GeneAcrossTrees--Endocrine
```{r}
pdf('EndocrineMarkers_26PC_1.2gran_afterDoubletRemoval_6.12.20.pdf')
FeaturePlot(object = All_Islet_DoubletRemoved_Norm_VariableGenes_Scaled_PCA_Jack_Cluster_UMAP, features = c("INS", "IAPP", "SST", "GCG", "PPY", "GHRL"))
dev.off()
```

# GeneAcrossTrees--Endocrine
```{r}
pdf('CD69_14PC_2.0gran_afterDoubletRemoved.pdf')
FeaturePlot(object = All_Islet_DoubletRemoved_Norm_VariableGenes_Scaled_PCA_Jack_Cluster_UMAP, features = "CD69")
dev.off()
```

# INS Trees--Endocrine
```{r}
pdf('INS_14PC_2.0gran_afterDoubletRemoved.pdf')
FeaturePlot(object = All_Islet_DoubletRemoved_Norm_VariableGenes_Scaled_PCA_Jack_Cluster_UMAP, features = "INS")
dev.off()
```

# IAPP Trees--Endocrine
```{r}
pdf('IAPP_14PC_2.0gran_afterDoubletRemoved.pdf')
FeaturePlot(object = All_Islet_DoubletRemoved_Norm_VariableGenes_Scaled_PCA_Jack_Cluster_UMAP, features = "IAPP")
dev.off()
```

# GCG Trees--Endocrine
```{r}
pdf('GCG_14PC_2.0gran_afterDoubletRemoved.pdf')
FeaturePlot(object = All_Islet_DoubletRemoved_Norm_VariableGenes_Scaled_PCA_Jack_Cluster_UMAP, features = "GCG")
dev.off()
```


```{r}
library(ggplot2)
```


# Violin Plots
```{r}
pdf('ViolinPlot_EndocrineMarkers_26PC_1.2gran.pdf')
VlnPlot(object = All_Islet_DoubletRemoved_Norm_VariableGenes_Scaled_PCA_Jack_Cluster_UMAP, features = c("INS", "IAPP", "SST", "GCG", "PPY", "GHRL"))
dev.off()
```


```{r}
pdf('INS_VP_26PC_1.2gran_noPoints.pdf')
VlnPlot(object = All_Islet_DoubletRemoved_Norm_VariableGenes_Scaled_PCA_Jack_Cluster_UMAP, features = 'INS', pt.size = 0) + theme(legend.position="none")
dev.off()
```



```{r}
pdf('IAPP_VP_26PC_1.2gran_noPoints.pdf')
VlnPlot(object = All_Islet_DoubletRemoved_Norm_VariableGenes_Scaled_PCA_Jack_Cluster_UMAP, features = 'IAPP', pt.size = 0) + theme(legend.position="none")
dev.off()
```



```{r}
pdf('GCG_VP_26PC_1.2gran_noPoints.pdf')
VlnPlot(object = All_Islet_DoubletRemoved_Norm_VariableGenes_Scaled_PCA_Jack_Cluster_UMAP, features = 'GCG', pt.size = 0) + theme(legend.position="none")
dev.off()
```


```{r}
pdf('SST_VP_26PC_1.2gran_noPoints.pdf')
VlnPlot(object = All_Islet_DoubletRemoved_Norm_VariableGenes_Scaled_PCA_Jack_Cluster_UMAP, features = 'SST', pt.size = 0) + theme(legend.position="none")
dev.off()
```




```{r}
pdf('PPY_VP_26PC_1.2gran_noPoints.pdf')
VlnPlot(object = All_Islet_DoubletRemoved_Norm_VariableGenes_Scaled_PCA_Jack_Cluster_UMAP, features = 'PPY', pt.size = 0) + theme(legend.position="none")
dev.off()
```


```{r}
pdf('GHRL_VP_26PC_1.2gran_noPoints.pdf')
VlnPlot(object = All_Islet_DoubletRemoved_Norm_VariableGenes_Scaled_PCA_Jack_Cluster_UMAP, features = 'GHRL', pt.size = 0) + theme(legend.position="none")
dev.off()
```


```{r}
pdf('CPA1_VP_26PC_1.2gran_noPoints.pdf')
VlnPlot(object = All_Islet_DoubletRemoved_Norm_VariableGenes_Scaled_PCA_Jack_Cluster_UMAP, features = 'CPA1', pt.size = 0) + theme(legend.position="none")
dev.off()
```



```{r}
pdf('KRT19_VP_26PC_1.2gran.pdf')
VlnPlot(object = All_Islet_DoubletRemoved_Norm_VariableGenes_Scaled_PCA_Jack_Cluster_UMAP, features = 'KRT19') + theme(legend.position="none")
dev.off()
```



```{r}
pdf('RGS10_VP_26PC_1.2gran_noPoints.pdf')
VlnPlot(object = All_Islet_DoubletRemoved_Norm_VariableGenes_Scaled_PCA_Jack_Cluster_UMAP, features = 'RGS10', pt.size = 0) + theme(legend.position="none")
dev.off()
```



```{r}
pdf('PDGFRA_VP_26PC_1.2gran.pdf')
VlnPlot(object = All_Islet_DoubletRemoved_Norm_VariableGenes_Scaled_PCA_Jack_Cluster_UMAP, features = 'PDGFRA') + theme(legend.position="none")
dev.off()
```



```{r}
pdf('SOX10_VP_26PC_1.2gran_noPoints.pdf')
VlnPlot(object = All_Islet_DoubletRemoved_Norm_VariableGenes_Scaled_PCA_Jack_Cluster_UMAP, features = 'SOX10', pt.size = 0) + theme(legend.position="none")
dev.off()
```



```{r}
pdf('VWF_VP_26PC_1.2gran_noPoints.pdf')
VlnPlot(object = All_Islet_DoubletRemoved_Norm_VariableGenes_Scaled_PCA_Jack_Cluster_UMAP, features = 'VWF', pt.size = 0) + theme(legend.position="none")
dev.off()
```


```{r}
pdf('PTPRC_VP_26PC_1.2gran_noPoints.pdf')
VlnPlot(object = All_Islet_DoubletRemoved_Norm_VariableGenes_Scaled_PCA_Jack_Cluster_UMAP, features = 'PTPRC', pt.size = 0) + theme(legend.position="none")
dev.off()
```


```{r}
pdf('CD4_VP_36PC_1.2gran_noPoints.pdf')
VlnPlot(object = All_Islet_DoubletRemoved_Norm_VariableGenes_Scaled_PCA_Jack_Cluster_UMAP, features = 'CD4', pt.size = 0) + theme(legend.position="none")
dev.off()
```



```{r}
pdf('CD8A_VP_26PC_1.2gran_noPoints.pdf')
VlnPlot(object = All_Islet_DoubletRemoved_Norm_VariableGenes_Scaled_PCA_Jack_Cluster_UMAP, features = 'CD8A', pt.size = 0) + theme(legend.position="none")
dev.off()
```


```{r}
pdf('CD8B_VP_26PC_1.2gran_noPoints.pdf')
VlnPlot(object = All_Islet_DoubletRemoved_Norm_VariableGenes_Scaled_PCA_Jack_Cluster_UMAP, features = 'CD8B', pt.size = 0) + theme(legend.position="none")
dev.off()
```


```{r}
pdf('TRAC_VP_11PC_1.2gran_noPoints.pdf')
VlnPlot(object = All_Islet_DoubletRemoved_Norm_VariableGenes_Scaled_PCA_Jack_Cluster_UMAP, features = 'TRAC', pt.size = 0) + theme(legend.position="none")
dev.off()
```



```{r}
pdf('CD14_VP_26PC_1.2gran_noPoints.pdf')
VlnPlot(object = All_Islet_DoubletRemoved_Norm_VariableGenes_Scaled_PCA_Jack_Cluster_UMAP, features = 'CD14', pt.size = 0) + theme(legend.position="none")
dev.off()
```



```{r}
pdf('SDS_VP_26PC_1.2gran_noPoints.pdf')
VlnPlot(object = All_Islet_DoubletRemoved_Norm_VariableGenes_Scaled_PCA_Jack_Cluster_UMAP, features = 'SDS', pt.size = 0) + theme(legend.position="none")
dev.off()
```



```{r}
pdf('TPSAB1_VP_11PC_1.2gran_noPoints.pdf')
VlnPlot(object = All_Islet_DoubletRemoved_Norm_VariableGenes_Scaled_PCA_Jack_Cluster_UMAP, features = 'TPSAB1', pt.size = 0) + theme(legend.position="none")
dev.off()
```



```{r}
pdf('TPSB2_VP_11PC_1.2gran_noPoints.pdf')
VlnPlot(object = All_Islet_DoubletRemoved_Norm_VariableGenes_Scaled_PCA_Jack_Cluster_UMAP, features = 'TPSB2', pt.size = 0) + theme(legend.position="none")
dev.off()
```


```{r}
pdf('SPI1_VP_11PC_1.2gran_noPoints.pdf')
VlnPlot(object = All_Islet_DoubletRemoved_Norm_VariableGenes_Scaled_PCA_Jack_Cluster_UMAP, features = 'SPI1', pt.size = 0) + theme(legend.position="none")
dev.off()
```


```{r}
pdf('KRT19_VP_11PC_1.2gran_noPoints.pdf')
VlnPlot(object = All_Islet_DoubletRemoved_Norm_VariableGenes_Scaled_PCA_Jack_Cluster_UMAP, features = 'KRT19', pt.size = 0) + theme(legend.position="none")
dev.off()
```




# UMAP plot by group


#adding cluster and sample info to seurat object
```{r}
group<-gsub(".*-","", colnames(All_Islet_DoubletRemoved_Norm_VariableGenes_Scaled_PCA_Jack_Cluster_UMAP))
group<-gsub("1","Control_A", group) #1
group<-gsub("2","Control_B", group) #2
group<-gsub("3","Control_C", group) #3
group<-gsub("4","Control_D", group) #4
group<-gsub("5","Control_E", group) #5
group<-gsub("6","Control_F", group) #6
group<-gsub("7","Control_G", group) #7
group<-gsub("8","Control_H", group) #8
group<-gsub("9","Control_I", group) #9
group<-gsub("Control_A0","Control_J", group) #10
group<-gsub("Control_AControl_A","Control_K", group) #11
group<-gsub("Control_AControl_B","AAB_A", group) #12
group<-gsub("Control_AControl_C","AAB_B", group) #13
group<-gsub("Control_AControl_D","AAB_C", group) #14
group<-gsub("Control_AControl_E","AAB_D", group) #15
group<-gsub("Control_AControl_F","AAB_E", group) #16
group<-gsub("Control_AControl_G","AAB_F", group) #17
group<-gsub("Control_AControl_H","AAB_G", group) #18
group<-gsub("Control_AControl_I","AAB_H", group) #19
group<-gsub("Control_B0","T1D_A", group) #20
group<-gsub("Control_BControl_A","T1D_B", group) #21
group<-gsub("Control_BControl_B","T1D_C", group) #22
group<-gsub("Control_BControl_C","T1D_D", group) #23
group<-gsub("Control_BControl_D","T1D_D", group) #24
group<-gsub("Control_BControl_E","T1D_E", group) #25
group

#group<-gsub("ControlControl","T1D", group) #11
#group<-gsub("ControlAAB_Pos","T1D", group) #12


```


## add group info to seurat object
```{r}
group.info <- data.frame(group = group, row.names= colnames(All_Islet_DoubletRemoved_Norm_VariableGenes_Scaled_PCA_Jack_Cluster_UMAP))
All_Islet_DoubletRemoved_Norm_VariableGenes_Scaled_PCA_Jack_Cluster_UMAP_GROUP <- AddMetaData(object = All_Islet_DoubletRemoved_Norm_VariableGenes_Scaled_PCA_Jack_Cluster_UMAP, metadata = group.info)
#All_Islet_DoubletRemoved_Norm_VariableGenes_Scaled_PCA_Jack_Cluster_UMAP_GROUP <- Idents(object = All_Islet_DoubletRemoved_Norm_VariableGenes_Scaled_PCA_Jack_Cluster_UMAP_GROUP, id = "group")
```

# UMAP plot by group

```{r}
pdf('UMAP_byGroup.pdf')
DimPlot(All_Islet_DoubletRemoved_Norm_VariableGenes_Scaled_PCA_Jack_Cluster_UMAP_GROUP, group.by = "group", reduction = "umap", label = FALSE, cols= c("#db6e1a", "#db6e1a", "#db6e1a", "#db6e1a", "#db6e1a", "#db6e1a", "#db6e1a", "#db6e1a", "#00a650", "#00a650", "#00a650", "#00a650", "#00a650", "#00a650", "#00a650", "#00a650", "#00a650", "#00a650", "#00a650", "#9102ad", "#9102ad", "#9102ad", "#9102ad", "#9102ad")) 
dev.off()
```

# UMAP plot by individual

```{r}
pdf('UMAP_byIndividual.pdf')
DimPlot(All_Islet_DoubletRemoved_Norm_VariableGenes_Scaled_PCA_Jack_Cluster_UMAP_GROUP, group.by = "group", reduction = "umap", label = FALSE, cols= c("#ff3c00", "#e0d9ce", "#FBCEB1", "#F88379", "#EE7F2D", "#FFD700", "#BF5700", "#703800", "#02bd37", "#87A96B", "#84877a", "#71BC78", "#29AB87", "#BFFF00", "#317478", "#628000", "#4FFFB0", "#3FFF00", "#006400", "#C71585", "#BF00FF", "#9370DB", "#B768A2", "#D8BFD8")) 
dev.off()
```

# UMAP plot by AABtype

```{r}
pdf('UMAP_byAAB.pdf')
DimPlot(All_Islet_DoubletRemoved_Norm_VariableGenes_Scaled_PCA_Jack_Cluster_UMAP_GROUP_DONOR, group.by = "donor", reduction = "umap", label = FALSE, cols= c("#e30800", "#000000", "#000000", "#000000", "#000000","#005eff", "#bf9600", "#8100c6", "#e30800", "#e30800", "#00990a", "#000000", "#00990a", "#000000")) 
dev.off()
```

# UMAP plot by Sex

```{r}
pdf('UMAP_bySex.pdf')
DimPlot(All_Islet_DoubletRemoved_Norm_VariableGenes_Scaled_PCA_Jack_Cluster_UMAP_GROUP_DONOR, group.by = "donor", reduction = "umap", label = FALSE, cols= c("#bf9600", "#bf9600", "#bf9600", "#000000", "#000000","#000000", "#bf9600", "#bf9600", "#bf9600", "#bf9600", "#000000", "#bf9600", "#000000", "#000000")) 
dev.off()
```

#bf9600 - yellow = males
#000000 - black = females


# UMAP plot by age

```{r}
pdf('UMAP_byAge.pdf')
DimPlot(All_Islet_DoubletRemoved_Norm_VariableGenes_Scaled_PCA_Jack_Cluster_UMAP_GROUP_DONOR, group.by = "donor", reduction = "umap", label = FALSE, cols= c("#00990a", "#005eff", "#bf9600", "#005eff", "#00990a","#e30800", "#bf9600", "#e30800", "#bf9600", "#00990a", "#bf9600", "#00990a", "#bf9600", "#005eff")) 
dev.off()
```

#e30800 = red = 0-10 ages
#bf9600 = yellow = 11-20 ages
#00990a = green = 21-30 ages
#005eff = blue = 31-40 ages


###### GARNETT ###########

### which cells are immune cells
```{r}
#CLuster26 <- as.matrix(GetAssayData(All_Islet_DoubletRemoved_Norm_VariableGenes_Scaled_PCA_Jack_Cluster_UMAP_GROUP_DONOR, slot = "counts")[, WhichCells(All_Islet_DoubletRemoved_Norm_VariableGenes_Scaled_PCA_Jack_Cluster_UMAP_GROUP_DONOR, ident = c("26"))])
```

```{r}
#write.table(as.matrix(CLuster26), file="CLuster26.txt", quote=FALSE, sep = "\t", row.names=TRUE)
```


```{r}
